import { Geist, Geist_Mono } from "next/font/google";  --> This line brings in two fonts – Geist and Geist Mono – from Google Fonts using Next.js’s built-in support.

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

        - Geist(...) → Loads the Geist Sans font.
        - variable: "--font-geist-sans" → Saves the font into a CSS variable so we can use it later in styles.
        - subsets: ["latin"] → Only loads letters used in English and similar languages to reduce size.

className={`${geistSans.variable} ${geistMono.variable} antialiased`}
        - Adds the Geist Sans font via CSS variable.
        - Adds the Geist Mono font via CSS variable.
        - antialiased → Makes text smoother and easier to read.




In TypeScript, Readonly is a utility type that makes all the properties of an object immutable, meaning they cannot be changed after they are set. It ensures that the object is treated as read-only, which helps prevent accidental modifications.

    Why is it used here?
        In your code, Readonly<{ children: React.ReactNode }> is used to make the children property immutable. This means that inside the RootLayout component, you cannot accidentally reassign or modify the children prop. It enforces the idea that props passed to a React component should not be changed.

    Example to clarify:
    Why is this useful?
        Immutability: It ensures that props or objects are not accidentally modified, which aligns with React's principle of immutability.
        
        Code Safety: It makes your code safer and easier to debug by preventing unintended side effects.
        In your case, using Readonly ensures that the children prop passed to RootLayout remains unchanged, which is a good practice for React components.


generator client {
  provider = "prisma-client-js"
  output   = "../node_modules/.prisma/client"
}
        ** you need to add an output property since starting with Prisma 7.0.0, specifying this path will be mandatory. 
        ** The path "../node_modules/.prisma/client" is the default location where Prisma generates its client, so this change just makes it explicit rather than relying on the default behavior.


what is difference between .env and .env.local file ?
    .env	    --> Shared config for all devs/envs
    .env.local	--> Dev-specific or secret overrides. It overrides values in .env


**  In Next.js, using the NEXT_PUBLIC_ prefix in your .env variables is not always necessary, but it is required if you want to access the variable in the browser (client-side). If you want to use the environment variable on the frontend (in React components, etc.), you must prefix it with NEXT_PUBLIC_



const [createUserWithEmailAndPassword, user, loading, error] = useCreateUserWithEmailAndPassword(auth)
        createUserWithEmailAndPassword → a function to create a user with email + password
        user → info about the signed-up user (if successful)
        loading → true while the request is in progress
        error → any error that happens during signup


** OAuth (short for Open Authorization) is an open standard authorization protocol that allows one application to access data from another application without exposing user credentials (like username or password).
OAuth lets you log into one app using another app safely.

        Example:
        When you click "Sign in with Google" on a website — that website doesn’t get your Google password.
        Instead, Google verifies you and tells the website:
        ✅ "Yes, this user is valid, and here’s some basic info (like name and email)."

        🔐 Key Roles in OAuth:

                -> User	                - The person using the app
                -> Client               - The app requesting access (like your website)
                -> Authorization Server	- The system that checks the user (e.g., Google, Facebook)
                -> Resource Server      - Where the data lives (e.g., user’s email, profile, etc.)
                -> Access Token	        - A temporary key that gives access to protected data without a password


-----

const sendOtp = async () => {
  if (!recaptchaRef.current) {
    recaptchaRef.current = new RecaptchaVerifier(auth, 'recaptcha-container', {
      size: 'invisible',
      callback: () => {
        console.log('reCAPTCHA solved')
      },
    })
  }
}
                Checks if reCAPTCHA is already created (!recaptchaRef.current)
                If not, it creates a new RecaptchaVerifier from Firebase.
                        - auth                  : your Firebase auth instance.
                        - 'recaptcha-container' : the HTML element where reCAPTCHA attaches.
                        - size: 'invisible'     : means the reCAPTCHA won't be shown visually (it runs silently).
                        - callback              : runs once the reCAPTCHA is successfully solved.

                Firebase requires reCAPTCHA before sending OTPs for security reasons:
                        - 🛡️ Prevents abuse	Stops bots from spamming OTP requests.
                        - ⚠️ Cost control	OTPs cost money. reCAPTCHA helps make sure only real users trigger them.


const result = await signInWithPhoneNumber(auth, phone, recaptchaRef.current)
        - auth                  : your Firebase authentication instance.
        - phone                 : the phone number you entered (e.g., +91xxxxxxxxxx).
        - recaptchaRef.current  : the reCAPTCHA verifier that ensures it's a human.

        It returns a confirmationResult object.
        This object contains a method called .confirm(userOTP), which you use later to verify the OTP entered by the user.

-------

The line ref={(el) => { inputRefs.current[index] = el; }} is using React's ref system to create references to DOM elements. Let me break it down in detail:

What it does:
        This code creates a direct reference to each input field in your OTP form, storing these references in an array so you can access and manipulate them programmatically.

How it works step by step:

        1. React's ref prop:

                - The ref prop in React lets you get a reference to the actual DOM element that gets rendered
                - Instead of passing a ref object directly, you're using a callback function approach


        2. Callback function:

                (el) => { inputRefs.current[index] = el; } is a callback function that React calls when:

                        - The component is mounted (with the actual DOM element as el)
                        - The component is unmounted (with null as el)

        3. Parameter el:

                - el is the actual DOM element (an <input> in this case) when the component renders
                - el becomes null when the component unmounts


        4. Storage in inputRefs:

                - inputRefs is a React useRef object created earlier with:
                        const inputRefs = useRef<(HTMLInputElement | null)[]>([null, null, null, null, null, null])

                - inputRefs.current is the mutable array that persists between renders
                - inputRefs.current[index] = el stores each input element at its corresponding index position


        5. The curly braces:

                -{ inputRefs.current[index] = el; } uses block syntax to make sure the function doesn't return anything
                -This addresses TypeScript's requirements for ref callbacks to have a void return type
